import os
import logging
from flask import Flask, render_template, request, redirect, url_for, flash, get_flashed_messages, jsonify, make_response, abort
from sqlalchemy import create_engine, func, or_
from sqlalchemy.orm import sessionmaker, scoped_session, joinedload
from sqlalchemy.sql import func as sql_func
from models import Base, Producto, Cliente, Pedido, PedidoProducto
import business_logic
from datetime import datetime, timedelta
import pandas as pd
from io import BytesIO
from dotenv import load_dotenv
import pymysql

# Cargar variables de entorno
load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv('SECRET_KEY', 'florezcook-secret-key')

# Configuración de la base de datos
def connect_unix_socket():
    """Configura la conexión a Cloud SQL para entornos de producción."""
    db_user = os.environ['DB_USER']
    db_pass = os.environ['DB_PASS']
    db_name = os.environ['DB_NAME']
    db_host = os.environ['DB_HOST']
    
    # Si estamos en producción, usamos la conexión Unix socket
    if os.getenv('ENV') == 'production':
        import google.cloud.sql.connector
        from google.cloud.sql.connector import Connector, IPTypes
        
        connector = Connector()
        
        def getconn():
            conn = connector.connect(
                os.environ['CLOUD_SQL_CONNECTION_NAME'],
                "pymysql",
                user=db_user,
                password=db_pass,
                db=db_name,
                ip_type=IPTypes.PRIVATE if os.environ.get('PRIVATE_IP') else IPTypes.PUBLIC
            )
            return conn
            
        return create_engine(
            "mysql+pymysql://",
            creator=getconn,
            pool_size=5,
            max_overflow=2,
            pool_timeout=30,
            pool_recycle=1800,
            pool_pre_ping=True
        )
    else:
        # Configuración para desarrollo local
        return create_engine(
            f"mysql+pymysql://{db_user}:{db_pass}@{os.getenv('DB_HOST', 'localhost')}/{db_name}",
            pool_size=5,
            max_overflow=2,
            pool_timeout=30,
            pool_recycle=1800,
            pool_pre_ping=True
        )

# Configurar el motor de la base de datos
try:
    engine = connect_unix_socket()
    # Verificar la conexión
    with engine.connect() as conn:
        print("Conexión a la base de datos establecida correctamente")
except Exception as e:
    print(f"Error al conectar a la base de datos: {e}")
    raise

# Crear tablas si no existen
Base.metadata.create_all(bind=engine)

# Configurar la sesión de SQLAlchemy
SessionLocal = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))

@app.teardown_appcontext
def remove_session(exception=None):
    SessionLocal.remove()

@app.route('/')
def index():
    return redirect(url_for('pedido_form'))

@app.route('/pedidos', methods=['GET', 'POST'])
def pedido_form():
    db = SessionLocal()
    productos = db.query(Producto).all()
    productos_dict = [
        {
            "id": p.id,
            "codigo": p.codigo,
            "referencia_de_producto": p.referencia_de_producto,
            "gramaje_g": p.gramaje_g,
            "formulacion_grupo": p.formulacion_grupo,
            "categoria_linea": p.categoria_linea
        }
        for p in productos
    ]
    current_year = datetime.now().year

    # Get client ID and show_welcome flag from query params
    cliente_id = request.args.get('cliente_id')
    show_welcome = request.args.get('show_welcome', '').lower() == 'true'
    cliente_data = {}
    if cliente_id:
        cliente = db.query(Cliente).get(cliente_id)
        if cliente:
            cliente_data = {
                'direccion_entrega': cliente.direccion,
                'ciudad_entrega': cliente.ciudad,
                'departamento_entrega': cliente.departamento,
                'show_welcome_message': show_welcome
            }

    if request.method == 'POST':
        form_data = dict(request.form)
        pedido_items = []
        idx = 0
        while True:
            key = f'producto_id_{idx}'
            if key not in form_data:
                break
            if form_data.get(key):
                pedido_items.append({
                    'producto_id': int(form_data.get(f'producto_id_{idx}', 0)),
                    'cantidad': form_data.get(f'cantidad_{idx}', ''),
                    'gramaje_g_item': form_data.get(f'gramaje_g_item_{idx}', ''),
                    'peso_total_g_item': form_data.get(f'peso_total_g_item_{idx}', ''),
                    'grupo_item': form_data.get(f'grupo_item_{idx}', ''),
                    'linea_item': form_data.get(f'linea_item_{idx}', ''),
                    'fecha_de_entrega_item': form_data.get(f'fecha_de_entrega_item_{idx}', ''),
                    'observaciones_item': form_data.get(f'observaciones_item_{idx}', ''),
                    'estado_del_pedido_item': form_data.get(f'estado_del_pedido_item_{idx}', 'Pendiente'),
                })
            idx += 1

        form_data['pedido_items'] = pedido_items
        success, result = business_logic.guardar_pedido_completo(db, form_data)

        if success:
            flash('Pedido guardado correctamente.', 'success')
            return redirect(url_for('pedido_form'))
        else:
            for error in result:
                flash(error, 'danger')
            form_state = business_logic.inicializar_estado_nuevo_pedido()
            form_state.update(form_data)
            form_state['show_seccion_registro'] = bool(form_data.get('show_seccion_registro'))
            form_state['show_seccion_despacho'] = True
            form_state['show_subform_pedido'] = True
            return render_template('pedido_form.html', form_data=form_state, productos=productos_dict, current_year=current_year)
    else:
        form_state = business_logic.inicializar_estado_nuevo_pedido()
        form_state.update(cliente_data)  # Prefill with client data
        show_welcome_message = request.args.get('show_welcome', '').lower() == 'true'
        return render_template('pedido_form.html', 
                            form_data=form_state, 
                            productos=productos_dict, 
                            current_year=current_year,
                            show_welcome_message=show_welcome_message)

@app.route('/productos')
def productos_list():
    db = SessionLocal()
    productos = db.query(Producto).all()
    current_year = datetime.now().year
    return render_template('productos_list.html', productos=productos, current_year=current_year)

@app.route('/clientes')
def clientes_list():
    db = SessionLocal()
    clientes = db.query(Cliente).all()
    current_year = datetime.now().year
    return render_template('clientes_list.html', clientes=clientes, current_year=current_year)

@app.route('/importar-productos', methods=['GET', 'POST'])
def importar_productos():
    db = SessionLocal()
    current_year = datetime.now().year
    
    if request.method == 'POST':
        if 'archivo' not in request.files:
            return redirect(request.url)
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            return redirect(request.url)
            
        if archivo:
            try:
                # Leer el archivo Excel
                df = pd.read_excel(archivo)
                
                # Validar columnas requeridas
                columnas_requeridas = ['codigo', 'referencia_de_producto', 'gramaje_g', 'formulacion_grupo', 'categoria_linea']
                for col in columnas_requeridas:
                    if col not in df.columns:
                        raise ValueError(f'Falta la columna requerida: {col}')
                
                # Procesar cada fila
                resultados = {'exito': True, 'mensaje': 'Productos importados correctamente', 'errores': []}
                for _, fila in df.iterrows():
                    try:
                        producto = Producto(
                            codigo=fila.get('codigo', ''),
                            referencia_de_producto=fila.get('referencia_de_producto', ''),
                            gramaje_g=float(fila.get('gramaje_g', 0)),
                            formulacion_grupo=fila.get('formulacion_grupo', ''),
                            categoria_linea=fila.get('categoria_linea', ''),
                            descripcion=fila.get('descripcion', ''),
                            precio_unitario=float(fila.get('precio_unitario', 0)) if pd.notna(fila.get('precio_unitario')) else 0,
                            unidad_medida=fila.get('unidad_medida', 'unidad'),
                            estado='Activo' if fila.get('estado', '').lower() in ['activo', '1', 'sí', 'si', 'true'] else 'Inactivo'
                        )
                        db.add(producto)
                        db.commit()
                    except Exception as e:
                        db.rollback()
                        resultados['errores'].append(f'Error en fila {_ + 2}: {str(e)}')
                
                if resultados['errores']:
                    resultados['exito'] = False
                    resultados['mensaje'] = 'Se produjeron algunos errores durante la importación'
                
                return render_template('importar_productos.html', 
                                     resultados=resultados,
                                     current_year=current_year)
                
            except Exception as e:
                error_msg = f'Error al procesar el archivo: {str(e)}'
                return render_template('importar_productos.html', 
                                     resultados={'exito': False, 'mensaje': error_msg, 'errores': [error_msg]},
                                     current_year=current_year)
    
    return render_template('importar_productos.html', current_year=current_year)

@app.route('/importar-clientes', methods=['GET', 'POST'])
def importar_clientes():
    db = SessionLocal()
    current_year = datetime.now().year
    
    if request.method == 'POST':
        if 'archivo' not in request.files:
            return redirect(request.url)
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            return redirect(request.url)
            
        if archivo:
            try:
                # Leer el archivo Excel
                df = pd.read_excel(archivo)
                
                # Validar columnas requeridas
                columnas_requeridas = ['nombre_comercial', 'tipo_identificacion', 'numero_identificacion']
                for col in columnas_requeridas:
                    if col not in df.columns:
                        raise ValueError(f'Falta la columna requerida: {col}')
                
                # Procesar cada fila
                resultados = {'exito': True, 'mensaje': 'Clientes importados correctamente', 'errores': []}
                for _, fila in df.iterrows():
                    try:
                        cliente = Cliente(
                            nombre_comercial=fila.get('nombre_comercial', ''),
                            razon_social=fila.get('razon_social', fila.get('nombre_comercial', '')),
                            tipo_identificacion=fila.get('tipo_identificacion', ''),
                            numero_identificacion=str(fila.get('numero_identificacion', '')),
                            digito_verificacion=str(fila.get('digito_verificacion', '')) if pd.notna(fila.get('digito_verificacion')) else None,
                            direccion=fila.get('direccion', ''),
                            direccion_ciudad=fila.get('ciudad', ''),
                            direccion_departamento=fila.get('departamento', ''),
                            direccion_pais=fila.get('pais', 'Colombia'),
                            telefono=str(fila.get('telefono', '')),
                            email=fila.get('email', ''),
                            responsable=fila.get('responsable', ''),
                            cargo=fila.get('cargo', ''),
                            actividad_economica=fila.get('actividad_economica', '')
                        )
                        db.add(cliente)
                        db.commit()
                    except Exception as e:
                        db.rollback()
                        resultados['errores'].append(f'Error en fila {_ + 2}: {str(e)}')
                
                if resultados['errores']:
                    resultados['exito'] = False
                    resultados['mensaje'] = 'Se produjeron algunos errores durante la importación'
                
                return render_template('importar_clientes.html', 
                                     resultados=resultados,
                                     current_year=current_year)
                
            except Exception as e:
                error_msg = f'Error al procesar el archivo: {str(e)}'
                return render_template('importar_clientes.html', 
                                     resultados={'exito': False, 'mensaje': error_msg, 'errores': [error_msg]},
                                     current_year=current_year)
    
    return render_template('importar_clientes.html', current_year=current_year)

@app.route('/productos/agregar', methods=['GET', 'POST'])
def agregar_producto():
    db = SessionLocal()
    current_year = datetime.now().year
    if request.method == 'POST':
        codigo = request.form.get('codigo')
        referencia = request.form.get('referencia_de_producto')
        gramaje = request.form.get('gramaje_g')
        grupo = request.form.get('formulacion_grupo')
        linea = request.form.get('categoria_linea')
        if not codigo or not referencia or not gramaje:
            flash('Todos los campos obligatorios deben ser completados.', 'danger')
            return render_template('producto_form.html', current_year=current_year, modo='agregar')
        prod = Producto(codigo=codigo, referencia_de_producto=referencia, gramaje_g=gramaje, formulacion_grupo=grupo, categoria_linea=linea)
        db.add(prod)
        db.commit()
        flash('Producto agregado correctamente.', 'success')
        return redirect(url_for('productos_list'))
    return render_template('producto_form.html', current_year=current_year, modo='agregar')

@app.route('/productos/editar/<int:producto_id>', methods=['GET', 'POST'])
def editar_producto(producto_id):
    db = SessionLocal()
    prod = db.query(Producto).get(producto_id)
    current_year = datetime.now().year
    if not prod:
        flash('Producto no encontrado.', 'danger')
        return redirect(url_for('productos_list'))
    if request.method == 'POST':
        prod.codigo = request.form.get('codigo')
        prod.referencia_de_producto = request.form.get('referencia_de_producto')
        prod.gramaje_g = request.form.get('gramaje_g')
        prod.formulacion_grupo = request.form.get('formulacion_grupo')
        prod.categoria_linea = request.form.get('categoria_linea')
        db.commit()
        flash('Producto actualizado correctamente.', 'success')
        return redirect(url_for('productos_list'))
    return render_template('producto_form.html', producto=prod, current_year=current_year, modo='editar')

@app.route('/productos/eliminar/<int:producto_id>', methods=['POST'])
def eliminar_producto(producto_id):
    db = SessionLocal()
    prod = db.query(Producto).get(producto_id)
    if prod:
        db.delete(prod)
        db.commit()
        flash('Producto eliminado.', 'success')
    else:
        flash('Producto no encontrado.', 'danger')
    return redirect(url_for('productos_list'))

@app.route('/productos/ver/<int:producto_id>')
def ver_producto(producto_id):
    db = SessionLocal()
    producto = db.query(Producto).get(producto_id)
    if not producto:
        flash('Producto no encontrado', 'danger')
        return redirect(url_for('productos_list'))
    return render_template('ver_producto.html', producto=producto)

@app.route('/clientes/agregar', methods=['GET', 'POST'])
def agregar_cliente():
    db = SessionLocal()
    current_year = datetime.now().year
    
    # Obtener parámetros de la URL para GET o del formulario para POST
    if request.method == 'POST':
        redirect_to = request.form.get('redirect_to', '')
        nit = request.form.get('nit', '')
    else:
        redirect_to = request.args.get('redirect_to', '')
        nit = request.args.get('nit', '')

    if request.method == 'POST':
        nombre = request.form.get('nombre_comercial')
        razon = request.form.get('razon_social')
        tipo = request.form.get('tipo_identificacion')
        numero = request.form.get('numero_identificacion')
        email = request.form.get('email')
        telefono = request.form.get('telefono')
        direccion = request.form.get('direccion')
        ciudad = request.form.get('ciudad')
        departamento = request.form.get('departamento')

        # Validación básica
        if not all([nombre, razon, tipo, numero, email, telefono, direccion, ciudad, departamento]):
            flash('Todos los campos son requeridos.', 'danger')
            return render_template('cliente_form.html', 
                                current_year=current_year, 
                                modo='agregar',
                                nit_default=nit, 
                                redirect_to=redirect_to)
        
        try:
            # Crear el nuevo cliente
            cli = Cliente(
                nombre_comercial=nombre,
                razon_social=razon,
                tipo_identificacion=tipo,
                numero_identificacion=numero,
                email=email,
                telefono=telefono,
                direccion=direccion,
                ciudad=ciudad,
                departamento=departamento
            )
            db.add(cli)
            db.commit()
            
            flash('Cliente agregado correctamente.', 'success')
            
            # Redirigir según corresponda
            if redirect_to == 'pedidos':
                return redirect(url_for('pedido_form', cliente_id=cli.id, show_welcome='true'))
            return redirect(url_for('clientes_list'))
            
        except Exception as e:
            db.rollback()
            flash(f'Error al guardar el cliente: {str(e)}', 'danger')
            
    # Renderizar el formulario (GET o si hay error en POST)
    return render_template('cliente_form.html', 
                         current_year=current_year, 
                         modo='agregar',
                         nit_default=nit, 
                         redirect_to=redirect_to)

@app.route('/clientes/editar/<int:cliente_id>', methods=['GET', 'POST'])
def editar_cliente(cliente_id):
    db = SessionLocal()
    cli = db.query(Cliente).get(cliente_id)
    current_year = datetime.now().year
    if not cli:
        flash('Cliente no encontrado.', 'danger')
        return redirect(url_for('clientes_list'))
    if request.method == 'POST':
        cli.nombre_comercial = request.form.get('nombre_comercial')
        cli.razon_social = request.form.get('razon_social')
        cli.tipo_identificacion = request.form.get('tipo_identificacion')
        cli.numero_identificacion = request.form.get('numero_identificacion')
        cli.email = request.form.get('email')
        cli.telefono = request.form.get('telefono')
        cli.direccion = request.form.get('direccion')
        cli.ciudad = request.form.get('ciudad')
        cli.departamento = request.form.get('departamento')
        db.commit()
        flash('Cliente actualizado correctamente.', 'success')
        return redirect(url_for('clientes_list'))
    return render_template('cliente_form.html', cliente=cli, current_year=current_year, modo='editar')

@app.route('/clientes/eliminar/<int:cliente_id>', methods=['POST'])
def eliminar_cliente(cliente_id):
    db = SessionLocal()
    cli = db.query(Cliente).get(cliente_id)
    if cli:
        db.delete(cli)
        db.commit()
        flash('Cliente eliminado.', 'success')
    else:
        flash('Cliente no encontrado.', 'danger')
    return redirect(url_for('clientes_list'))

@app.route('/clientes/ver/<int:cliente_id>')
def ver_cliente(cliente_id):
    db = SessionLocal()
    cliente = db.query(Cliente).get(cliente_id)
    if not cliente:
        flash('Cliente no encontrado', 'danger')
        return redirect(url_for('clientes_list'))
    return render_template('ver_cliente.html', cliente=cliente, current_year=datetime.now().year)

@app.route('/api/clientes/buscar', methods=['GET'])
def buscar_cliente():
    nit = request.args.get('nit')
    db = SessionLocal()
    cliente = db.query(Cliente).filter(Cliente.numero_identificacion == nit).first()
    if cliente:
        return jsonify({
            'existe': True,
            'id': cliente.id,
            'nombre_comercial': cliente.nombre_comercial,
            'razon_social': cliente.razon_social,
            'tipo_identificacion': cliente.tipo_identificacion,
            'numero_identificacion': cliente.numero_identificacion,
            'email': cliente.email,
            'telefono': cliente.telefono,
            'direccion': cliente.direccion,
            'ciudad': cliente.ciudad,
            'departamento': cliente.departamento
        })
    else:
        return jsonify({'existe': False})

from flask import make_response
from io import BytesIO
import pandas as pd
from datetime import timedelta

@app.route('/reportes/pedidos')
def reporte_pedidos():
    db = SessionLocal()
    
    # Obtener parámetros de filtro
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    estado = request.args.get('estado')
    cliente_id = request.args.get('cliente_id')
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    # Obtener lista de clientes para el dropdown
    clientes = db.query(Cliente).order_by(Cliente.nombre_comercial).all()
    
    # Construir consulta base
    query = db.query(Pedido).options(joinedload(Pedido.cliente_asociado))
    
    # Aplicar filtros
    if fecha_desde:
        fecha_desde = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde)
    
    if fecha_hasta:
        fecha_hasta = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta)
    
    if estado:
        query = query.filter(Pedido.estado == estado)
        
    if cliente_id and cliente_id != 'todos':
        query = query.filter(Pedido.cliente_id == cliente_id)
    
    # Ordenar por fecha de creación descendente
    query = query.order_by(Pedido.fecha_creacion.desc())
    
    # Calcular total de registros
    total_pedidos = query.count()
    
    # Calcular páginas totales
    total_paginas = (total_pedidos + per_page - 1) // per_page
    
    # Aplicar paginación manual
    offset = (page - 1) * per_page
    pedidos = query.offset(offset).limit(per_page).all()
    
    # Crear objeto de paginación personalizado
    class Pagination:
        def __init__(self, page, per_page, total, items):
            self.page = page
            self.per_page = per_page
            self.total = total
            self.items = items
            self.pages = (total + per_page - 1) // per_page
            self.has_prev = page > 1
            self.has_next = page < self.pages
            self.prev_num = page - 1 if self.has_prev else None
            self.next_num = page + 1 if self.has_next else None
    
    pagination = Pagination(
        page=page,
        per_page=per_page,
        total=total_pedidos,
        items=pedidos
    )
    
    return render_template('reporte_pedidos.html', 
                         pedidos=pedidos,
                         pagination=pagination,
                         total_pedidos=total_pedidos,
                         clientes=clientes,
                         cliente_id=cliente_id)

@app.route('/exportar-pedidos-excel')
def exportar_pedidos_excel():
    db = SessionLocal()
    
    # Obtener parámetros de filtro (mismos que en el reporte)
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    estado = request.args.get('estado')
    
    # Construir consulta base
    query = db.query(Pedido).options(joinedload(Pedido.cliente_asociado), joinedload(Pedido.items).joinedload(PedidoProducto.producto_asociado))
    
    # Aplicar filtros
    if fecha_desde:
        fecha_desde = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde)
    
    if fecha_hasta:
        fecha_hasta = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta)
    
    if estado:
        query = query.filter(Pedido.estado == estado)
    
    # Obtener datos
    pedidos = query.order_by(Pedido.fecha_creacion.desc()).all()
    
    # Crear DataFrame con los datos
    data = []
    for pedido in pedidos:
        cliente = pedido.cliente_asociado
        # Calcular el total sumando los items del pedido (cantidad * gramaje)
        total_pedido = sum(item.cantidad * (item.gramaje_g_item or 0) for item in pedido.items)
        
        data.append({
            'ID Pedido': pedido.id,
            'Fecha': pedido.fecha_creacion.strftime('%Y-%m-%d %H:%M'),
            'Cliente': cliente.nombre_comercial if cliente else 'N/A',
            'NIT/CC': cliente.numero_identificacion if cliente else 'N/A',
            'Estado': pedido.estado_pedido_general,
            'Cantidad Total (g)': total_pedido,
            'Dirección de Entrega': pedido.direccion_entrega or '',
            'Ciudad': pedido.ciudad_entrega or '',
            'Departamento': pedido.departamento_entrega or '',
            'Observaciones': pedido.observaciones_despacho or ''
        })
    
    # Crear Excel
    output = BytesIO()
    df = pd.DataFrame(data)
    df.to_excel(output, index=False, sheet_name='Reporte de Pedidos')
    
    # Configurar respuesta
    output.seek(0)
    response = make_response(output.getvalue())
    response.mimetype = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    response.headers['Content-Disposition'] = 'attachment; filename=reporte_pedidos.xlsx'
    
    return response

@app.route('/pedidos/ver/<int:pedido_id>')
def ver_pedido(pedido_id):
    db = SessionLocal()
    pedido = db.query(Pedido).options(
        joinedload(Pedido.cliente_asociado),
        joinedload(Pedido.items).joinedload(PedidoProducto.producto_asociado)
    ).filter(Pedido.id == pedido_id).first()
    
    if not pedido:
        flash('Pedido no encontrado', 'danger')
        return redirect(url_for('reporte_pedidos'))
    
    # Calculate total weight and value
    total_peso = sum(item.peso_total_g_item or 0 for item in pedido.items)
    total_valor = sum((item.cantidad or 0) * (item.producto_asociado.gramaje_g or 0) for item in pedido.items)
    
    current_year = datetime.now().year
    return render_template('ver_pedido.html', 
                         pedido=pedido, 
                         total_peso=total_peso,
                         total_valor=total_valor,
                         current_year=current_year)

@app.route('/pedidos/editar/<int:pedido_id>', methods=['GET', 'POST'])
def editar_pedido(pedido_id):
    db = SessionLocal()
    pedido = db.query(Pedido).options(
        joinedload(Pedido.cliente_asociado),
        joinedload(Pedido.items).joinedload(PedidoProducto.producto_asociado)
    ).filter(Pedido.id == pedido_id).first()
    
    if not pedido:
        flash('Pedido no encontrado', 'danger')
        return redirect(url_for('reporte_pedidos'))
    
    if request.method == 'POST':
        try:
            # Update order status
            nuevo_estado = request.form.get('estado')
            if nuevo_estado in Pedido.ESTADOS_PEDIDO:
                pedido.estado_pedido_general = nuevo_estado
            
            # Update shipping info
            pedido.despacho_tipo = request.form.get('despacho_tipo')
            pedido.direccion_entrega = request.form.get('direccion_entrega')
            pedido.ciudad_entrega = request.form.get('ciudad_entrega')
            pedido.departamento_entrega = request.form.get('departamento_entrega')
            pedido.despacho_horario_atencion = request.form.get('despacho_horario_atencion')
            pedido.observaciones_despacho = request.form.get('observaciones_despacho')
            pedido.alerta = request.form.get('alerta')
            
            # Update order items
            # First, delete existing items
            for item in pedido.items:
                db.delete(item)
            
            # Add updated items
            item_idx = 0
            while True:
                producto_id = request.form.get(f'producto_id_{item_idx}')
                if not producto_id:
                    break
                
                cantidad = request.form.get(f'cantidad_{item_idx}')
                gramaje = request.form.get(f'gramaje_g_item_{item_idx}')
                observaciones = request.form.get(f'observaciones_item_{item_idx}')
                fecha_entrega = request.form.get(f'fecha_de_entrega_item_{item_idx}')
                estado = request.form.get(f'estado_del_pedido_item_{item_idx}', 'Pendiente')
                
                if producto_id and cantidad and gramaje:
                    item = PedidoProducto(
                        pedido_id=pedido.id,
                        producto_id=producto_id,
                        cantidad=cantidad,
                        gramaje_g_item=gramaje,
                        observaciones_item=observaciones,
                        fecha_de_entrega_item=fecha_entrega,
                        estado_del_pedido_item=estado
                    )
                    db.add(item)
                
                item_idx += 1
            
            db.commit()
            flash('Pedido actualizado correctamente', 'success')
            return redirect(url_for('ver_pedido', pedido_id=pedido.id))
            
        except Exception as e:
            db.rollback()
            flash(f'Error al actualizar el pedido: {str(e)}', 'danger')
    
    # Get all products for the dropdown
    productos = db.query(Producto).all()
    productos_dict = [{"id": p.id, "codigo": p.codigo, "referencia_de_producto": p.referencia_de_producto} 
                     for p in productos]
    
    current_year = datetime.now().year
    return render_template('editar_pedido.html', 
                         pedido=pedido, 
                         estados=Pedido.ESTADOS_PEDIDO,
                         productos=productos_dict,
                         current_year=current_year)

@app.route('/pedidos/eliminar/<int:pedido_id>', methods=['POST'])
def eliminar_pedido(pedido_id):
    db = SessionLocal()
    pedido = db.query(Pedido).get(pedido_id)
    
    if not pedido:
        flash('Pedido no encontrado', 'danger')
        return redirect(url_for('reporte_pedidos'))
    
    try:
        # Delete related items first (due to foreign key constraints)
        db.query(PedidoProducto).filter(PedidoProducto.pedido_id == pedido_id).delete()
        db.delete(pedido)
        db.commit()
        flash('Pedido eliminado correctamente', 'success')
    except Exception as e:
        db.rollback()
        flash(f'Error al eliminar el pedido: {str(e)}', 'danger')
    
    return redirect(url_for('reporte_pedidos'))

@app.route('/pedidos/lista')
def lista_pedidos():
    db = SessionLocal()
    pedidos = db.query(Pedido).order_by(Pedido.fecha_creacion.desc()).all()
    current_year = datetime.now().year
    return render_template('pedidos_lista.html', pedidos=pedidos, current_year=current_year)

@app.route('/reportes/consolidado-productos')
def consolidado_productos():
    db = SessionLocal()
    
    # Get filter parameters
    estado = request.args.get('estado')
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    categoria = request.args.get('categoria')
    cliente_id = request.args.get('cliente_id')
    
    # Build base query
    query = db.query(
        Producto.categoria_linea.label('categoria'),
        Producto.formulacion_grupo.label('formulacion'),
        Producto.referencia_de_producto.label('referencia'),
        Pedido.id.label('pedido_id'),
        Pedido.observaciones_despacho.label('observaciones'),
        sql_func.sum(PedidoProducto.cantidad).label('total_cantidad'),
        sql_func.sum(PedidoProducto.peso_total_g_item).label('total_peso')
    ).join(
        PedidoProducto, 
        Producto.id == PedidoProducto.producto_id
    ).join(
        Pedido,
        Pedido.id == PedidoProducto.pedido_id
    ).group_by(
        Producto.id,
        Pedido.id,
        Pedido.observaciones_despacho
    )
    
    # Apply filters
    if estado:
        query = query.filter(Pedido.estado_pedido_general == estado)
    
    if fecha_desde:
        fecha_desde = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde)
    
    if fecha_hasta:
        fecha_hasta = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta)
    
    if categoria:
        query = query.filter(Producto.categoria_linea == categoria)
    
    if cliente_id and cliente_id != 'todos':
        query = query.filter(Pedido.cliente_id == cliente_id)
    
    # Get unique clients for the filter dropdown
    clientes = db.query(Cliente).order_by(Cliente.nombre_comercial).all()
    
    # Get unique categories for the filter dropdown
    categorias = db.query(Producto.categoria_linea).distinct().all()
    categorias = [c[0] for c in categorias if c[0]]
    
    # Execute the query
    resultados = query.all()
    
    # Calculate totals
    total_cantidad = sum(r.total_cantidad or 0 for r in resultados)
    total_peso = sum(r.total_peso or 0 for r in resultados)
    
    current_year = datetime.now().year
    return render_template('consolidado_productos.html', 
                         resultados=resultados,
                         total_cantidad=total_cantidad,
                         total_peso=total_peso,
                         estados=Pedido.ESTADOS_PEDIDO,
                         categorias=categorias,
                         clientes=clientes,
                         filtros={
                             'estado': estado,
                             'fecha_desde': fecha_desde.strftime('%Y-%m-%d') if fecha_desde else '',
                             'fecha_hasta': (fecha_hasta - timedelta(days=1)).strftime('%Y-%m-%d') if fecha_hasta else '',
                             'categoria': categoria,
                             'cliente_id': cliente_id
                         },
                         current_year=current_year)

@app.route('/exportar-consolidado-excel')
def exportar_consolidado_excel():
    db = SessionLocal()
    
    # Get filter parameters (same as consolidado_productos)
    estado = request.args.get('estado')
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    categoria = request.args.get('categoria')
    cliente_id = request.args.get('cliente_id')
    
    # Build the same query as in consolidado_productos
    query = db.query(
        Producto.categoria_linea.label('categoria'),
        Producto.formulacion_grupo.label('formulacion'),
        Producto.referencia_de_producto.label('referencia'),
        Pedido.id.label('pedido_id'),
        Pedido.observaciones_despacho.label('observaciones'),
        sql_func.sum(PedidoProducto.cantidad).label('total_cantidad'),
        sql_func.sum(PedidoProducto.peso_total_g_item).label('total_peso')
    ).join(
        PedidoProducto, 
        Producto.id == PedidoProducto.producto_id
    ).join(
        Pedido,
        Pedido.id == PedidoProducto.pedido_id
    ).group_by(
        Producto.id,
        Pedido.id,
        Pedido.observaciones_despacho
    )
    
    # Apply filters (same as in consolidado_productos)
    if estado:
        query = query.filter(Pedido.estado_pedido_general == estado)
    
    if fecha_desde:
        fecha_desde_dt = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde_dt)
    
    if fecha_hasta:
        fecha_hasta_dt = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta_dt)
    
    if categoria:
        query = query.filter(Producto.categoria_linea == categoria)
    
    if cliente_id and cliente_id != 'todos':
        query = query.filter(Pedido.cliente_id == cliente_id)
    
    # Execute the query
    resultados = query.all()
    
    # Prepare data for Excel
    data = []
    for item in resultados:
        data.append({
            'Categoría': item.categoria or '',
            'Formulación': item.formulacion or '',
            'Referencia de Producto': item.referencia or '',
            'N° Pedido': item.pedido_id,
            'Observaciones': item.observaciones or '',
            'Cantidad': float(item.total_cantidad or 0),
            'Peso Total (g)': float(item.total_peso or 0)
        })
    
    # Create Excel file
    output = BytesIO()
    df = pd.DataFrame(data)
    
    # Calculate totals
    total_cantidad = df['Cantidad'].sum()
    total_peso = df['Peso Total (g)'].sum()
    
    # Create a new DataFrame for the totals row
    totals_row = pd.DataFrame({
        'Categoría': ['TOTALES'],
        'Formulación': [''],
        'Referencia de Producto': [''],
        'N° Pedido': [''],
        'Observaciones': [''],
        'Cantidad': [total_cantidad],
        'Peso Total (g)': [total_peso]
    })
    
    # Concatenate the original DataFrame with the totals row
    df = pd.concat([df, totals_row], ignore_index=True)
    
    # Write to Excel
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, sheet_name='Consolidado Productos', index=False)
        
        # Get workbook and worksheet objects
        workbook = writer.book
        worksheet = writer.sheets['Consolidado Productos']
        
        # Add formats
        header_format = workbook.add_format({
            'bold': True,
            'text_wrap': True,
            'valign': 'top',
            'bg_color': '#D9EAD3',
            'border': 1
        })
        
        total_format = workbook.add_format({
            'bold': True,
            'num_format': '0.00',
            'bg_color': '#F4CCCC',
            'border': 1
        })
        
        # Format the header
        for col_num, value in enumerate(df.columns.values):
            worksheet.write(0, col_num, value, header_format)
        
        # Format the totals row
        last_row = len(df)
        for col_num, col in enumerate(df.columns):
            if col in ['Cantidad', 'Peso Total (g)']:
                worksheet.write(last_row - 1, col_num, df.iloc[-1][col], total_format)
        
        # Set column widths
        worksheet.set_column('A:A', 20)  # Categoría
        worksheet.set_column('B:B', 20)  # Formulación
        worksheet.set_column('C:C', 30)  # Referencia
        worksheet.set_column('D:D', 10)  # N° Pedido
        worksheet.set_column('E:E', 40)  # Observaciones
        worksheet.set_column('F:G', 15)  # Cantidad y Peso
    
    # Prepare response
    output.seek(0)
    response = make_response(output.getvalue())
    response.mimetype = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    response.headers['Content-Disposition'] = 'attachment; filename=consolidado_productos.xlsx'
    
    return response

@app.route('/pedidos/consolidado')
def consolidado_pedidos():
    return redirect(url_for('consolidado_productos'))

if __name__ == '__main__':
    app.run(debug=True, port=5001)
