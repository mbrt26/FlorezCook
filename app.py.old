import os
import logging
import pandas as pd
import business_logic
from flask import Flask, render_template, request, redirect, url_for, flash, get_flashed_messages, jsonify, make_response, abort
from sqlalchemy import create_engine, func, or_, text
from sqlalchemy.orm import sessionmaker, scoped_session, joinedload
from sqlalchemy.sql import func as sql_func
from models import Base, Producto, Cliente, Pedido, PedidoProducto
from datetime import datetime, timedelta
from io import BytesIO
from dotenv import load_dotenv
import pymysql

# Cargar variables de entorno
load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv('SECRET_KEY', 'florezcook-secret-key')

# Función placeholder para compatibilidad
def access_secret(secret_id):
    """Función placeholder para desarrollo local"""
    if secret_id == 'florezcook-secret-key':
        return os.getenv('SECRET_KEY', 'clave-desarrollo-local-florez-cook-2024')
    elif secret_id == 'florezcook-db-password':
        return os.getenv('DB_PASS', '')
    elif secret_id == 'cloud-sql-connection':
        return os.getenv('CLOUD_SQL_CONNECTION_NAME', '')
    return None

# Health check endpoints
@app.route('/healthz')
def liveness():
    try:
        # Verificar la conexión a la base de datos
        db = SessionLocal()
        try:
            db.execute(text('SELECT 1'))
            return jsonify({"status": "healthy"}), 200
        finally:
            db.close()
    except Exception as e:
        app.logger.error(f"Health check failed: {e}")
        return jsonify({"status": "unhealthy", "error": str(e)}), 500

@app.route('/readiness')
def readiness():
    try:
        # Verificar la conexión a la base de datos
        db = SessionLocal()
        try:
            db.execute(text('SELECT 1'))
            return jsonify({"status": "ready"}), 200
        finally:
            db.close()
    except Exception as e:
        app.logger.error(f"Readiness check failed: {e}")
        return jsonify({"status": "not ready", "error": str(e)}), 503

# Configuración de la base de datos
def connect_unix_socket():
    """Configura la conexión a Cloud SQL para entornos de producción."""
    db_user = os.environ['DB_USER']
    db_pass = os.environ['DB_PASS']
    db_name = os.environ['DB_NAME']
    db_host = os.environ['DB_HOST']
    
    # Si estamos en producción, usamos la conexión Unix socket
    if os.getenv('ENV') == 'production':
        import google.cloud.sql.connector
        from google.cloud.sql.connector import Connector, IPTypes
        
        connector = Connector()
        
        def getconn():
            conn = connector.connect(
                os.environ['CLOUD_SQL_CONNECTION_NAME'],
                "pymysql",
                user=db_user,
                password=db_pass,
                db=db_name,
                ip_type=IPTypes.PRIVATE if os.environ.get('PRIVATE_IP') else IPTypes.PUBLIC
            )
            return conn
            
        return create_engine(
            "mysql+pymysql://",
            creator=getconn,
            pool_size=5,
            max_overflow=2,
            pool_timeout=30,
            pool_recycle=1800,
            pool_pre_ping=True
        )
    else:
        # Configuración para desarrollo local
        return create_engine(
            f"mysql+pymysql://{db_user}:{db_pass}@{os.getenv('DB_HOST', 'localhost')}/{db_name}",
            pool_size=5,
            max_overflow=2,
            pool_timeout=30,
            pool_recycle=1800,
            pool_pre_ping=True
        )

# Configurar el motor de la base de datos
try:
    engine = connect_unix_socket()
    # Verificar la conexión
    with engine.connect() as conn:
        print("Conexión a la base de datos establecida correctamente")
except Exception as e:
    print(f"Error al conectar a la base de datos: {e}")
    raise

# Crear tablas si no existen
Base.metadata.create_all(bind=engine)

# Configurar la sesión de SQLAlchemy
SessionLocal = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))

@app.teardown_appcontext
def remove_session(exception=None):
    SessionLocal.remove()

@app.route('/')
def index():
    try:
        # Verificar que la base de datos esté disponible antes de redirigir
        db = SessionLocal()
        try:
            db.execute(text('SELECT 1'))
            return redirect(url_for('pedido_form'))
        finally:
            db.close()
    except Exception as e:
        app.logger.error(f"Error en ruta index: {e}")
        return f"Error interno del servidor: {str(e)}", 500

@app.route('/pedidos', methods=['GET', 'POST'])
def pedido_form():
    db = SessionLocal()
    try:
        productos = db.query(Producto).all()
        productos_dict = [
            {
                "id": p.id,
                "codigo": p.codigo,
                "referencia_de_producto": p.referencia_de_producto,
                "gramaje_g": p.gramaje_g,
                "formulacion_grupo": p.formulacion_grupo,
                "categoria_linea": p.categoria_linea
            }
            for p in productos
        ]
        current_year = datetime.now().year

        # Get client ID and show_welcome flag from query params
        cliente_id = request.args.get('cliente_id')
        show_welcome = request.args.get('show_welcome', '').lower() == 'true'
        cliente_data = {}
        if cliente_id:
            cliente = db.query(Cliente).get(cliente_id)
            if cliente:
                cliente_data = {
                    'direccion_entrega': cliente.direccion,
                    'ciudad_entrega': cliente.ciudad,
                    'departamento_entrega': cliente.departamento,
                    'show_welcome_message': show_welcome
                }

        if request.method == 'POST':
            form_data = dict(request.form)
            pedido_items = []
            idx = 0
            while True:
                key = f'producto_id_{idx}'
                if key not in form_data:
                    break
                if form_data.get(key):
                    pedido_items.append({
                        'producto_id': int(form_data.get(f'producto_id_{idx}', 0)),
                        'cantidad': form_data.get(f'cantidad_{idx}', ''),
                        'gramaje_g_item': form_data.get(f'gramaje_g_item_{idx}', ''),
                        'peso_total_g_item': form_data.get(f'peso_total_g_item_{idx}', ''),
                        'grupo_item': form_data.get(f'grupo_item_{idx}', ''),
                        'linea_item': form_data.get(f'linea_item_{idx}', ''),
                        'fecha_de_entrega_item': form_data.get(f'fecha_de_entrega_item_{idx}', ''),
                        'observaciones_item': form_data.get(f'observaciones_item_{idx}', ''),
                        'estado_del_pedido_item': form_data.get(f'estado_del_pedido_item_{idx}', 'Pendiente'),
                    })
                idx += 1

            form_data['pedido_items'] = pedido_items
            success, result = business_logic.guardar_pedido_completo(db, form_data)

            if success:
                flash('Pedido guardado correctamente.', 'success')
                return redirect(url_for('pedido_form'))
            else:
                for error in result:
                    flash(error, 'danger')
                form_state = business_logic.inicializar_estado_nuevo_pedido()
                form_state.update(form_data)
                form_state['show_seccion_registro'] = bool(form_data.get('show_seccion_registro'))
                form_state['show_seccion_despacho'] = True
                form_state['show_subform_pedido'] = True
                return render_template('pedido_form.html', form_data=form_state, productos=productos_dict, current_year=current_year)
        else:
            form_state = business_logic.inicializar_estado_nuevo_pedido()
            form_state.update(cliente_data)  # Prefill with client data
            show_welcome_message = request.args.get('show_welcome', '').lower() == 'true'
            return render_template('pedido_form.html', 
                                form_data=form_state, 
                                productos=productos_dict, 
                                current_year=current_year,
                                show_welcome_message=show_welcome_message)
    except Exception as e:
        app.logger.error(f"Error en pedido_form: {e}")
        return f"Error interno del servidor: {str(e)}", 500
    finally:
        db.close()

@app.route('/productos')
def productos_list():
    db = SessionLocal()
    try:
        productos = db.query(Producto).all()
        current_year = datetime.now().year
        return render_template('productos_list.html', productos=productos, current_year=current_year)
    finally:
        db.close()

@app.route('/clientes')
def clientes_list():
    db = SessionLocal()
    try:
        clientes = db.query(Cliente).all()
        current_year = datetime.now().year
        return render_template('clientes_list.html', clientes=clientes, current_year=current_year)
    finally:
        db.close()

@app.route('/importar-productos', methods=['GET', 'POST'])
def importar_productos():
    db = SessionLocal()
    current_year = datetime.now().year
    
    if request.method == 'POST':
        if 'archivo' not in request.files:
            return redirect(request.url)
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            return redirect(request.url)
            
        if archivo:
            try:
                # Leer el archivo Excel
                df = pd.read_excel(archivo)
                
                # Validar columnas requeridas
                columnas_requeridas = ['codigo', 'referencia_de_producto', 'gramaje_g', 'formulacion_grupo', 'categoria_linea']
                for col in columnas_requeridas:
                    if col not in df.columns:
                        raise ValueError(f'Falta la columna requerida: {col}')
                
                # Procesar cada fila
                resultados = {'exito': True, 'mensaje': 'Productos importados correctamente', 'errores': []}
                for _, fila in df.iterrows():
                    try:
                        producto = Producto(
                            codigo=fila.get('codigo', ''),
                            referencia_de_producto=fila.get('referencia_de_producto', ''),
                            gramaje_g=float(fila.get('gramaje_g', 0)),
                            formulacion_grupo=fila.get('formulacion_grupo', ''),
                            categoria_linea=fila.get('categoria_linea', ''),
                            descripcion=fila.get('descripcion', ''),
                            precio_unitario=float(fila.get('precio_unitario', 0)) if pd.notna(fila.get('precio_unitario')) else 0,
                            unidad_medida=fila.get('unidad_medida', 'unidad'),
                            estado='Activo' if fila.get('estado', '').lower() in ['activo', '1', 'sí', 'si', 'true'] else 'Inactivo'
                        )
                        db.add(producto)
                        db.commit()
                    except Exception as e:
                        db.rollback()
                        resultados['errores'].append(f'Error en fila {_ + 2}: {str(e)}')
                
                if resultados['errores']:
                    resultados['exito'] = False
                    resultados['mensaje'] = 'Se produjeron algunos errores durante la importación'
                
                return render_template('importar_productos.html', 
                                     resultados=resultados,
                                     current_year=current_year)
                
            except Exception as e:
                error_msg = f'Error al procesar el archivo: {str(e)}'
                return render_template('importar_productos.html', 
                                     resultados={'exito': False, 'mensaje': error_msg, 'errores': [error_msg]},
                                     current_year=current_year)
    
    return render_template('importar_productos.html', current_year=current_year)

@app.route('/importar-clientes', methods=['GET', 'POST'])
def importar_clientes():
    db = SessionLocal()
    current_year = datetime.now().year
    
    if request.method == 'POST':
        if 'archivo' not in request.files:
            return redirect(request.url)
        
        archivo = request.files['archivo']
        if archivo.filename == '':
            return redirect(request.url)
            
        if archivo:
            try:
                # Leer el archivo Excel
                df = pd.read_excel(archivo)
                
                # Validar columnas requeridas
                columnas_requeridas = ['nombre_comercial', 'tipo_identificacion', 'numero_identificacion']
                for col in columnas_requeridas:
                    if col not in df.columns:
                        raise ValueError(f'Falta la columna requerida: {col}')
                
                # Procesar cada fila
                resultados = {'exito': True, 'mensaje': 'Clientes importados correctamente', 'errores': []}
                for _, fila in df.iterrows():
                    try:
                        cliente = Cliente(
                            nombre_comercial=fila.get('nombre_comercial', ''),
                            razon_social=fila.get('razon_social', fila.get('nombre_comercial', '')),
                            tipo_identificacion=fila.get('tipo_identificacion', ''),
                            numero_identificacion=str(fila.get('numero_identificacion', '')),
                            digito_verificacion=str(fila.get('digito_verificacion', '')) if pd.notna(fila.get('digito_verificacion')) else None,
                            direccion=fila.get('direccion', ''),
                            direccion_ciudad=fila.get('ciudad', ''),
                            direccion_departamento=fila.get('departamento', ''),
                            direccion_pais=fila.get('pais', 'Colombia'),
                            telefono=str(fila.get('telefono', '')),
                            email=fila.get('email', ''),
                            responsable=fila.get('responsable', ''),
                            cargo=fila.get('cargo', ''),
                            actividad_economica=fila.get('actividad_economica', '')
                        )
                        db.add(cliente)
                        db.commit()
                    except Exception as e:
                        db.rollback()
                        resultados['errores'].append(f'Error en fila {_ + 2}: {str(e)}')
                
                if resultados['errores']:
                    resultados['exito'] = False
                    resultados['mensaje'] = 'Se produjeron algunos errores durante la importación'
                
                return render_template('importar_clientes.html', 
                                     resultados=resultados,
                                     current_year=current_year)
                
            except Exception as e:
                error_msg = f'Error al procesar el archivo: {str(e)}'
                return render_template('importar_clientes.html', 
                                     resultados={'exito': False, 'mensaje': error_msg, 'errores': [error_msg]},
                                     current_year=current_year)
    
    return render_template('importar_clientes.html', current_year=current_year)

@app.route('/productos/agregar', methods=['GET', 'POST'])
def agregar_producto():
    db = SessionLocal()
    current_year = datetime.now().year
    if request.method == 'POST':
        codigo = request.form.get('codigo')
        referencia = request.form.get('referencia_de_producto')
        gramaje = request.form.get('gramaje_g')
        grupo = request.form.get('formulacion_grupo')
        linea = request.form.get('categoria_linea')
        if not codigo or not referencia or not gramaje:
            flash('Todos los campos obligatorios deben ser completados.', 'danger')
            return render_template('producto_form.html', current_year=current_year, modo='agregar')
        prod = Producto(codigo=codigo, referencia_de_producto=referencia, gramaje_g=gramaje, formulacion_grupo=grupo, categoria_linea=linea)
        db.add(prod)
        db.commit()
        flash('Producto agregado correctamente.', 'success')
        return redirect(url_for('productos_list'))
    return render_template('producto_form.html', current_year=current_year, modo='agregar')

@app.route('/productos/editar/<int:producto_id>', methods=['GET', 'POST'])
def editar_producto(producto_id):
    db = SessionLocal()
    prod = db.query(Producto).get(producto_id)
    current_year = datetime.now().year
    if not prod:
        flash('Producto no encontrado.', 'danger')
        return redirect(url_for('productos_list'))
    if request.method == 'POST':
        prod.codigo = request.form.get('codigo')
        prod.referencia_de_producto = request.form.get('referencia_de_producto')
        prod.gramaje_g = request.form.get('gramaje_g')
        prod.formulacion_grupo = request.form.get('formulacion_grupo')
        prod.categoria_linea = request.form.get('categoria_linea')
        db.commit()
        flash('Producto actualizado correctamente.', 'success')
        return redirect(url_for('productos_list'))
    return render_template('producto_form.html', producto=prod, current_year=current_year, modo='editar')

@app.route('/productos/eliminar/<int:producto_id>', methods=['POST'])
def eliminar_producto(producto_id):
    db = SessionLocal()
    prod = db.query(Producto).get(producto_id)
    if prod:
        db.delete(prod)
        db.commit()
        flash('Producto eliminado.', 'success')
    else:
        flash('Producto no encontrado.', 'danger')
    return redirect(url_for('productos_list'))

@app.route('/productos/ver/<int:producto_id>')
def ver_producto(producto_id):
    db = SessionLocal()
    producto = db.query(Producto).get(producto_id)
    if not producto:
        flash('Producto no encontrado', 'danger')
        return redirect(url_for('productos_list'))
    return render_template('ver_producto.html', producto=producto)

@app.route('/clientes/agregar', methods=['GET', 'POST'])
def agregar_cliente():
    db = SessionLocal()
    current_year = datetime.now().year
    
    # Obtener parámetros de la URL para GET o del formulario para POST
    if request.method == 'POST':
        redirect_to = request.form.get('redirect_to', '')
        nit = request.form.get('nit', '')
    else:
        redirect_to = request.args.get('redirect_to', '')
        nit = request.args.get('nit', '')

    if request.method == 'POST':
        nombre = request.form.get('nombre_comercial')
        razon = request.form.get('razon_social')
        tipo = request.form.get('tipo_identificacion')
        numero = request.form.get('numero_identificacion')
        email = request.form.get('email')
        telefono = request.form.get('telefono')
        direccion = request.form.get('direccion')
        ciudad = request.form.get('ciudad')
        departamento = request.form.get('departamento')

        # Validación básica
        if not all([nombre, razon, tipo, numero, email, telefono, direccion, ciudad, departamento]):
            flash('Todos los campos son requeridos.', 'danger')
            return render_template('cliente_form.html', 
                                current_year=current_year, 
                                modo='agregar',
                                nit_default=nit, 
                                redirect_to=redirect_to,
                                departamentos_ciudades=DEPARTAMENTOS_CIUDADES)
        
        try:
            # Crear el nuevo cliente
            cli = Cliente(
                nombre_comercial=nombre,
                razon_social=razon,
                tipo_identificacion=tipo,
                numero_identificacion=numero,
                email=email,
                telefono=telefono,
                direccion=direccion,
                ciudad=ciudad,
                departamento=departamento
            )
            db.add(cli)
            db.commit()
            
            flash('Cliente agregado correctamente.', 'success')
            
            # Redirigir según corresponda
            if redirect_to == 'pedidos':
                return redirect(url_for('pedido_form', cliente_id=cli.id, show_welcome='true'))
            return redirect(url_for('clientes_list'))
            
        except Exception as e:
            db.rollback()
            flash(f'Error al guardar el cliente: {str(e)}', 'danger')
            
    # Renderizar el formulario (GET o si hay error en POST)
    return render_template('cliente_form.html', 
                         current_year=current_year, 
                         modo='agregar',
                         nit_default=nit, 
                         redirect_to=redirect_to,
                         departamentos_ciudades=DEPARTAMENTOS_CIUDADES)

@app.route('/clientes/editar/<int:cliente_id>', methods=['GET', 'POST'])
def editar_cliente(cliente_id):
    db = SessionLocal()
    cli = db.query(Cliente).get(cliente_id)
    current_year = datetime.now().year
    if not cli:
        flash('Cliente no encontrado.', 'danger')
        return redirect(url_for('clientes_list'))
    if request.method == 'POST':
        cli.nombre_comercial = request.form.get('nombre_comercial')
        cli.razon_social = request.form.get('razon_social')
        cli.tipo_identificacion = request.form.get('tipo_identificacion')
        cli.numero_identificacion = request.form.get('numero_identificacion')
        cli.email = request.form.get('email')
        cli.telefono = request.form.get('telefono')
        cli.direccion = request.form.get('direccion')
        cli.ciudad = request.form.get('ciudad')
        cli.departamento = request.form.get('departamento')
        db.commit()
        flash('Cliente actualizado correctamente.', 'success')
        return redirect(url_for('clientes_list'))
    return render_template('cliente_form.html', 
                         cliente=cli, 
                         current_year=current_year, 
                         modo='editar',
                         departamentos_ciudades=DEPARTAMENTOS_CIUDADES)

@app.route('/clientes/eliminar/<int:cliente_id>', methods=['POST'])
def eliminar_cliente(cliente_id):
    db = SessionLocal()
    cli = db.query(Cliente).get(cliente_id)
    if cli:
        db.delete(cli)
        db.commit()
        flash('Cliente eliminado.', 'success')
    else:
        flash('Cliente no encontrado.', 'danger')
    return redirect(url_for('clientes_list'))

@app.route('/clientes/ver/<int:cliente_id>')
def ver_cliente(cliente_id):
    db = SessionLocal()
    cliente = db.query(Cliente).get(cliente_id)
    if not cliente:
        flash('Cliente no encontrado', 'danger')
        return redirect(url_for('clientes_list'))
    return render_template('ver_cliente.html', cliente=cliente, current_year=datetime.now().year)

@app.route('/api/clientes/buscar', methods=['GET'])
def buscar_cliente():
    nit = request.args.get('nit')
    db = SessionLocal()
    cliente = db.query(Cliente).filter(Cliente.numero_identificacion == nit).first()
    if cliente:
        return jsonify({
            'existe': True,
            'id': cliente.id,
            'nombre_comercial': cliente.nombre_comercial,
            'razon_social': cliente.razon_social,
            'tipo_identificacion': cliente.tipo_identificacion,
            'numero_identificacion': cliente.numero_identificacion,
            'email': cliente.email,
            'telefono': cliente.telefono,
            'direccion': cliente.direccion,
            'ciudad': cliente.ciudad,
            'departamento': cliente.departamento
        })
    else:
        return jsonify({'existe': False})

from flask import make_response
from io import BytesIO
import pandas as pd
from datetime import timedelta

@app.route('/reportes/pedidos')
def reporte_pedidos():
    db = SessionLocal()
    
    # Obtener parámetros de filtro
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    estado = request.args.get('estado')
    cliente_id = request.args.get('cliente_id')
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    # Obtener lista de clientes para el dropdown
    clientes = db.query(Cliente).order_by(Cliente.nombre_comercial).all()
    
    # Construir consulta base
    query = db.query(Pedido).options(joinedload(Pedido.cliente_asociado))
    
    # Aplicar filtros
    if fecha_desde:
        fecha_desde = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde)
    
    if fecha_hasta:
        fecha_hasta = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta)
    
    if estado:
        query = query.filter(Pedido.estado_pedido_general == estado)
        
    if cliente_id and cliente_id != 'todos':
        query = query.filter(Pedido.cliente_id == cliente_id)
    
    # Ordenar por fecha de creación descendente
    query = query.order_by(Pedido.fecha_creacion.desc())
    
    # Calcular total de registros
    total_pedidos = query.count()
    
    # Calcular páginas totales
    total_paginas = (total_pedidos + per_page - 1) // per_page
    
    # Aplicar paginación manual
    offset = (page - 1) * per_page
    pedidos = query.offset(offset).limit(per_page).all()
    
    # Crear objeto de paginación personalizado
    class Pagination:
        def __init__(self, page, per_page, total, items):
            self.page = page
            self.per_page = per_page
            self.total = total
            self.items = items
            self.pages = (total + per_page - 1) // per_page
            self.has_prev = page > 1
            self.has_next = page < self.pages
            self.prev_num = page - 1 if self.has_prev else None
            self.next_num = page + 1 if self.has_next else None
    
    pagination = Pagination(
        page=page,
        per_page=per_page,
        total=total_pedidos,
        items=pedidos
    )
    
    return render_template('reporte_pedidos.html', 
                         pedidos=pedidos,
                         pagination=pagination,
                         total_pedidos=total_pedidos,
                         estados=Pedido.ESTADOS_PEDIDO,
                         clientes=clientes,
                         cliente_id=cliente_id)

@app.route('/exportar-pedidos-excel')
def exportar_pedidos_excel():
    db = SessionLocal()
    
    # Obtener parámetros de filtro (mismos que en el reporte)
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    estado = request.args.get('estado')
    
    # Construir consulta base
    query = db.query(Pedido).options(joinedload(Pedido.cliente_asociado), joinedload(Pedido.items).joinedload(PedidoProducto.producto_asociado))
    
    # Aplicar filtros
    if fecha_desde:
        fecha_desde = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde)
    
    if fecha_hasta:
        fecha_hasta = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta)
    
    if estado:
        query = query.filter(Pedido.estado == estado)
    
    try:
        # Obtener datos
        pedidos = query.order_by(Pedido.fecha_creacion.desc()).all()
        
        # Crear DataFrame with los datos
        data = []
        for pedido in pedidos:
            cliente = pedido.cliente_asociado
            try:
                # Calcular el total sumando los items del pedido (cantidad * gramaje)
                total_pedido = sum(item.cantidad * (item.gramaje_g_item or 0) for item in pedido.items)
            except Exception as e:
                app.logger.error(f"Error calculando total para pedido {pedido.id}: {str(e)}")
                total_pedido = 0
            
            data.append({
                'ID Pedido': pedido.id,
                'Fecha': pedido.fecha_creacion.strftime('%Y-%m-%d %H:%M'),
                'Cliente': cliente.nombre_comercial if cliente else 'N/A',
                'NIT/CC': cliente.numero_identificacion if cliente else 'N/A',
                'Estado': pedido.estado_pedido_general,
                'Cantidad Total (g)': total_pedido,
                'Dirección de Entrega': pedido.direccion_entrega or '',
                'Ciudad': pedido.ciudad_entrega or '',
                'Departamento': pedido.departamento_entrega or '',
                'Observaciones': pedido.observaciones_despacho or ''
            })
        
        # Crear Excel con manejo de errores
        output = BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            df = pd.DataFrame(data)
            df.to_excel(writer, index=False, sheet_name='Reporte de Pedidos')
            
            # Dar formato al Excel
            workbook = writer.book
            worksheet = writer.sheets['Reporte de Pedidos']
            
            # Formato para el encabezado
            header_format = workbook.add_format({
                'bold': True,
                'text_wrap': True,
                'valign': 'top',
                'bg_color': '#D9EAD3',
                'border': 1
            })
            
            # Aplicar formato al encabezado
            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, header_format)
                worksheet.set_column(col_num, col_num, 15)  # Ancho de columna
            
            # Ajustar columnas específicas
            worksheet.set_column('B:B', 20)  # Fecha
            worksheet.set_column('C:C', 30)  # Cliente
            worksheet.set_column('G:G', 35)  # Dirección
            worksheet.set_column('J:J', 40)  # Observaciones
        
        # Configurar respuesta
        output.seek(0)
        response = make_response(output.getvalue())
        response.mimetype = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = 'attachment; filename=reporte_pedidos.xlsx'
        return response
        
    except Exception as e:
        app.logger.error(f"Error generando el reporte Excel: {str(e)}")
        flash(f'Error generando el reporte: {str(e)}', 'danger')
        return redirect(url_for('reporte_pedidos'))

@app.route('/pedidos/ver/<int:pedido_id>')
def ver_pedido(pedido_id):
    db = SessionLocal()
    pedido = db.query(Pedido).options(
        joinedload(Pedido.cliente_asociado),
        joinedload(Pedido.items).joinedload(PedidoProducto.producto_asociado)
    ).filter(Pedido.id == pedido_id).first()
    
    if not pedido:
        flash('Pedido no encontrado', 'danger')
        return redirect(url_for('reporte_pedidos'))
    
    # Calculate total weight and value
    total_peso = sum(item.peso_total_g_item or 0 for item in pedido.items)
    total_valor = sum((item.cantidad or 0) * (item.producto_asociado.gramaje_g or 0) for item in pedido.items)
    
    current_year = datetime.now().year
    return render_template('ver_pedido.html', 
                         pedido=pedido, 
                         total_peso=total_peso,
                         total_valor=total_valor,
                         current_year=current_year)

@app.route('/pedidos/editar/<int:pedido_id>', methods=['GET', 'POST'])
def editar_pedido(pedido_id):
    db = SessionLocal()
    pedido = db.query(Pedido).options(
        joinedload(Pedido.cliente_asociado),
        joinedload(Pedido.items).joinedload(PedidoProducto.producto_asociado)
    ).filter(Pedido.id == pedido_id).first()
    
    if not pedido:
        flash('Pedido no encontrado', 'danger')
        return redirect(url_for('reporte_pedidos'))
    
    if request.method == 'POST':
        try:
            # Update order status
            nuevo_estado = request.form.get('estado')
            if nuevo_estado in Pedido.ESTADOS_PEDIDO:
                pedido.estado_pedido_general = nuevo_estado
            
            # Update shipping info
            pedido.despacho_tipo = request.form.get('despacho_tipo')
            pedido.direccion_entrega = request.form.get('direccion_entrega')
            pedido.ciudad_entrega = request.form.get('ciudad_entrega')
            pedido.departamento_entrega = request.form.get('departamento_entrega')
            pedido.despacho_horario_atencion = request.form.get('despacho_horario_atencion')
            pedido.observaciones_despacho = request.form.get('observaciones_despacho')
            pedido.alerta = request.form.get('alerta')
            
            # Update order items
            # First, delete existing items
            for item in pedido.items:
                db.delete(item)
            
            # Add updated items
            item_idx = 0
            while True:
                producto_id = request.form.get(f'producto_id_{item_idx}')
                if not producto_id:
                    break
                
                cantidad = request.form.get(f'cantidad_{item_idx}')
                gramaje = request.form.get(f'gramaje_g_item_{item_idx}')
                observaciones = request.form.get(f'observaciones_item_{item_idx}')
                fecha_entrega = request.form.get(f'fecha_de_entrega_item_{item_idx}')
                estado = request.form.get(f'estado_del_pedido_item_{item_idx}', 'Pendiente')
                
                if producto_id and cantidad and gramaje:
                    # Convertir fecha de string a objeto date si no está vacía
                    fecha_entrega_obj = None
                    if fecha_entrega:
                        try:
                            fecha_entrega_obj = datetime.strptime(fecha_entrega, '%Y-%m-%d').date()
                        except ValueError:
                            # Si la fecha no es válida, dejarla como None
                            fecha_entrega_obj = None
                    
                    item = PedidoProducto(
                        pedido_id=pedido.id,
                        producto_id=producto_id,
                        cantidad=cantidad,
                        gramaje_g_item=gramaje,
                        observaciones_item=observaciones,
                        fecha_de_entrega_item=fecha_entrega_obj,
                        estado_del_pedido_item=estado
                    )
                    db.add(item)
                
                item_idx += 1
            
            db.commit()
            flash('Pedido actualizado correctamente', 'success')
            return redirect(url_for('ver_pedido', pedido_id=pedido.id))
            
        except Exception as e:
            db.rollback()
            flash(f'Error al actualizar el pedido: {str(e)}', 'danger')
    
    # Get all products for the dropdown
    productos = db.query(Producto).all()
    productos_dict = [{"id": p.id, "codigo": p.codigo, "referencia_de_producto": p.referencia_de_producto} 
                     for p in productos]
    
    current_year = datetime.now().year
    return render_template('editar_pedido.html', 
                         pedido=pedido, 
                         estados=Pedido.ESTADOS_PEDIDO,
                         productos=productos_dict,
                         current_year=current_year)

@app.route('/pedidos/eliminar/<int:pedido_id>', methods=['POST'])
def eliminar_pedido(pedido_id):
    db = SessionLocal()
    pedido = db.query(Pedido).get(pedido_id)
    
    if not pedido:
        flash('Pedido no encontrado', 'danger')
        return redirect(url_for('reporte_pedidos'))
    
    try:
        # Delete related items first (due to foreign key constraints)
        db.query(PedidoProducto).filter(PedidoProducto.pedido_id == pedido_id).delete()
        db.delete(pedido)
        db.commit()
        flash('Pedido eliminado correctamente', 'success')
    except Exception as e:
        db.rollback()
        flash(f'Error al eliminar el pedido: {str(e)}', 'danger')
    
    return redirect(url_for('reporte_pedidos'))

@app.route('/pedidos/lista')
def lista_pedidos():
    db = SessionLocal()
    pedidos = db.query(Pedido).order_by(Pedido.fecha_creacion.desc()).all()
    current_year = datetime.now().year
    return render_template('pedidos_lista.html', pedidos=pedidos, current_year=current_year)

@app.route('/reportes/consolidado-productos')
def consolidado_productos():
    db = SessionLocal()
    
    # Get filter parameters
    estado = request.args.get('estado')
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    categoria = request.args.get('categoria')
    cliente_id = request.args.get('cliente_id')
    
    # Build base query - now including Cliente information
    query = db.query(
        Producto.categoria_linea.label('categoria'),
        Producto.formulacion_grupo.label('formulacion'),
        Producto.referencia_de_producto.label('referencia'),
        Pedido.id.label('pedido_id'),
        Cliente.nombre_comercial.label('cliente_nombre'),
        Cliente.numero_identificacion.label('cliente_nit'),
        sql_func.sum(PedidoProducto.cantidad).label('total_cantidad'),
        sql_func.sum(PedidoProducto.peso_total_g_item).label('total_peso')
    ).join(
        PedidoProducto, 
        Producto.id == PedidoProducto.producto_id
    ).join(
        Pedido,
        Pedido.id == PedidoProducto.pedido_id
    ).join(
        Cliente,
        Cliente.id == Pedido.cliente_id
    ).group_by(
        Producto.id,
        Pedido.id,
        Cliente.id,
        Cliente.nombre_comercial,
        Cliente.numero_identificacion
    )
    
    # Apply filters
    if estado:
        query = query.filter(Pedido.estado_pedido_general == estado)
    
    if fecha_desde:
        query = query.filter(Pedido.fecha_creacion >= fecha_desde)
    
    if fecha_hasta:
        fecha_hasta_dt = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta_dt)
    
    if categoria:
        query = query.filter(Producto.categoria_linea == categoria)
    
    if cliente_id and cliente_id != 'todos':
        query = query.filter(Pedido.cliente_id == cliente_id)
    
    # Get unique clients for the filter dropdown
    clientes = db.query(Cliente).order_by(Cliente.nombre_comercial).all()
    
    # Get unique categories for the filter dropdown
    categorias = db.query(Producto.categoria_linea).distinct().all()
    categorias = [c[0] for c in categorias if c[0]]
    
    # Execute the query and order by formulacion
    resultados = query.order_by(Producto.formulacion_grupo, Producto.referencia_de_producto).all()
    
    # Group results by formulacion and calculate subtotals
    resultados_agrupados = {}
    subtotales_formulacion = {}
    
    for item in resultados:
        formulacion = item.formulacion or 'Sin Formulación'
        
        if formulacion not in resultados_agrupados:
            resultados_agrupados[formulacion] = []
            subtotales_formulacion[formulacion] = {'cantidad': 0, 'peso': 0}
        
        resultados_agrupados[formulacion].append(item)
        subtotales_formulacion[formulacion]['cantidad'] += (item.total_cantidad or 0)
        subtotales_formulacion[formulacion]['peso'] += (item.total_peso or 0)
    
    # Calculate totals
    total_cantidad = sum(r.total_cantidad or 0 for r in resultados)
    total_peso = sum(r.total_peso or 0 for r in resultados)
    
    current_year = datetime.now().year
    return render_template('consolidado_productos.html', 
                         resultados=resultados,
                         resultados_agrupados=resultados_agrupados,
                         subtotales_formulacion=subtotales_formulacion,
                         total_cantidad=total_cantidad,
                         total_peso=total_peso,
                         estados=Pedido.ESTADOS_PEDIDO,
                         categorias=categorias,
                         clientes=clientes,
                         filtros={
                             'estado': estado,
                             'fecha_desde': fecha_desde.strftime('%Y-%m-%d') if fecha_desde else '',
                             'fecha_hasta': (fecha_hasta - timedelta(days=1)).strftime('%Y-%m-%d') if fecha_hasta else '',
                             'categoria': categoria,
                             'cliente_id': cliente_id
                         },
                         current_year=current_year)

@app.route('/exportar-consolidado-excel')
def exportar_consolidado_excel():
    db = SessionLocal()
    
    # Get filter parameters (same as consolidado_productos)
    estado = request.args.get('estado')
    fecha_desde = request.args.get('fecha_desde')
    fecha_hasta = request.args.get('fecha_hasta')
    categoria = request.args.get('categoria')
    cliente_id = request.args.get('cliente_id')
    
    # Build the same query as in consolidado_productos
    query = db.query(
        Producto.categoria_linea.label('categoria'),
        Producto.formulacion_grupo.label('formulacion'),
        Producto.referencia_de_producto.label('referencia'),
        Pedido.id.label('pedido_id'),
        Cliente.nombre_comercial.label('cliente_nombre'),
        Cliente.numero_identificacion.label('cliente_nit'),
        sql_func.sum(PedidoProducto.cantidad).label('total_cantidad'),
        sql_func.sum(PedidoProducto.peso_total_g_item).label('total_peso')
    ).join(
        PedidoProducto, 
        Producto.id == PedidoProducto.producto_id
    ).join(
        Pedido,
        Pedido.id == PedidoProducto.pedido_id
    ).join(
        Cliente,
        Cliente.id == Pedido.cliente_id
    ).group_by(
        Producto.id,
        Pedido.id,
        Cliente.id,
        Cliente.nombre_comercial,
        Cliente.numero_identificacion
    )
    
    # Apply filters (same as consolidado_productos)
    if estado:
        query = query.filter(Pedido.estado_pedido_general == estado)
    
    if fecha_desde:
        fecha_desde_dt = datetime.strptime(fecha_desde, '%Y-%m-%d')
        query = query.filter(Pedido.fecha_creacion >= fecha_desde_dt)
    
    if fecha_hasta:
        fecha_hasta_dt = datetime.strptime(fecha_hasta, '%Y-%m-%d') + timedelta(days=1)
        query = query.filter(Pedido.fecha_creacion <= fecha_hasta_dt)
    
    if categoria:
        query = query.filter(Producto.categoria_linea == categoria)
    
    if cliente_id and cliente_id != 'todos':
        query = query.filter(Pedido.cliente_id == cliente_id)
    
    # Execute the query and order by formulacion
    resultados = query.order_by(Producto.formulacion_grupo, Producto.referencia_de_producto).all()
    
    # Group results by formulacion and calculate subtotals (same logic as HTML)
    resultados_agrupados = {}
    subtotales_formulacion = {}
    
    for item in resultados:
        formulacion = item.formulacion or 'Sin Formulación'
        
        if formulacion not in resultados_agrupados:
            resultados_agrupados[formulacion] = []
            subtotales_formulacion[formulacion] = {'cantidad': 0, 'peso': 0}
        
        resultados_agrupados[formulacion].append(item)
        subtotales_formulacion[formulacion]['cantidad'] += (item.total_cantidad or 0)
        subtotales_formulacion[formulacion]['peso'] += (item.total_peso or 0)
    
    # Prepare data for Excel with grouping and subtotals
    data = []
    
    for formulacion, items in resultados_agrupados.items():
        # Add formulacion header row
        data.append({
            'Cliente': f'🧪 {formulacion}',
            'Categoría': '',
            'Formulación': '',
            'Referencia de Producto': '',
            'N° Pedido': '',
            'Cantidad': '',
            'Peso Total (g)': '',
            'Tipo_Fila': 'header_formulacion'
        })
        
        # Add items for this formulacion
        for item in items:
            data.append({
                'Cliente': f'{item.cliente_nombre} ({item.cliente_nit})',
                'Categoría': item.categoria or '-',
                'Formulación': item.formulacion or '-',
                'Referencia de Producto': item.referencia or '-',
                'N° Pedido': item.pedido_id,
                'Cantidad': float(item.total_cantidad or 0),
                'Peso Total (g)': float(item.total_peso or 0),
                'Tipo_Fila': 'item'
            })
        
        # Add subtotal row
        data.append({
            'Cliente': '',
            'Categoría': '',
            'Formulación': '',
            'Referencia de Producto': '',
            'N° Pedido': f'Subtotal {formulacion}:',
            'Cantidad': float(subtotales_formulacion[formulacion]['cantidad']),
            'Peso Total (g)': float(subtotales_formulacion[formulacion]['peso']),
            'Tipo_Fila': 'subtotal'
        })
    
    # Calculate totals
    total_cantidad = sum(r.total_cantidad or 0 for r in resultados)
    total_peso = sum(r.total_peso or 0 for r in resultados)
    
    # Add totals row
    data.append({
        'Cliente': '',
        'Categoría': '',
        'Formulación': '',
        'Referencia de Producto': '',
        'N° Pedido': 'TOTALES GENERALES:',
        'Cantidad': float(total_cantidad),
        'Peso Total (g)': float(total_peso),
        'Tipo_Fila': 'total'
    })
    
    # Create Excel file
    output = BytesIO()
    df = pd.DataFrame(data)
    
    # Remove the helper column before writing to Excel
    df_excel = df.drop('Tipo_Fila', axis=1)
    
    # Write to Excel with formatting
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df_excel.to_excel(writer, sheet_name='Consolidado Productos', index=False)
        
        # Get workbook and worksheet objects
        workbook = writer.book
        worksheet = writer.sheets['Consolidado Productos']
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'text_wrap': True,
            'valign': 'top',
            'bg_color': '#D9EAD3',
            'border': 1
        })
        
        formulacion_header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#D1ECF1',
            'border': 1,
            'font_size': 12
        })
        
        subtotal_format = workbook.add_format({
            'bold': True,
            'num_format': '0.00',
            'bg_color': '#FFF3CD',
            'border': 1
        })
        
        total_format = workbook.add_format({
            'bold': True,
            'num_format': '0.00',
            'bg_color': '#F4CCCC',
            'border': 1
        })
        
        # Format the header row
        for col_num, value in enumerate(df_excel.columns.values):
            worksheet.write(0, col_num, value, header_format)
        
        # Format data rows based on type
        for row_idx, row in df.iterrows():
            excel_row = row_idx + 1  # +1 because Excel is 1-indexed and we have headers
            
            if row['Tipo_Fila'] == 'header_formulacion':
                # Format formulacion header row
                for col_num in range(len(df_excel.columns)):
                    worksheet.write(excel_row, col_num, df_excel.iloc[row_idx, col_num], formulacion_header_format)
            
            elif row['Tipo_Fila'] == 'subtotal':
                # Format subtotal row
                for col_num, col_name in enumerate(df_excel.columns):
                    if col_name in ['Cantidad', 'Peso Total (g)']:
                        worksheet.write(excel_row, col_num, df_excel.iloc[row_idx, col_num], subtotal_format)
                    else:
                        cell_format = workbook.add_format({'bold': True, 'bg_color': '#FFF3CD', 'border': 1})
                        worksheet.write(excel_row, col_num, df_excel.iloc[row_idx, col_num], cell_format)
            
            elif row['Tipo_Fila'] == 'total':
                # Format total row
                for col_num, col_name in enumerate(df_excel.columns):
                    if col_name in ['Cantidad', 'Peso Total (g)']:
                        worksheet.write(excel_row, col_num, df_excel.iloc[row_idx, col_num], total_format)
                    else:
                        cell_format = workbook.add_format({'bold': True, 'bg_color': '#F4CCCC', 'border': 1})
                        worksheet.write(excel_row, col_num, df_excel.iloc[row_idx, col_num], cell_format)
        
        # Set column widths
        worksheet.set_column('A:A', 35)  # Cliente
        worksheet.set_column('B:B', 20)  # Categoría
        worksheet.set_column('C:C', 20)  # Formulación
        worksheet.set_column('D:D', 30)  # Referencia
        worksheet.set_column('E:E', 15)  # N° Pedido
        worksheet.set_column('F:G', 15)  # Cantidad y Peso
    
    # Prepare response
    output.seek(0)
    response = make_response(output.getvalue())
    response.mimetype = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    response.headers['Content-Disposition'] = 'attachment; filename=consolidado_productos.xlsx'
    
    return response

@app.route('/pedidos/consolidado')
def consolidado_pedidos():
    return redirect(url_for('consolidado_productos'))

# Datos de departamentos y ciudades de Colombia
DEPARTAMENTOS_CIUDADES = {
    'Amazonas': ['Leticia', 'Puerto Nariño'],
    'Antioquia': ['Medellín', 'Bello', 'Itagüí', 'Envigado', 'Apartadó', 'Turbo', 'Rionegro', 'Sabaneta', 'La Estrella', 'Copacabana'],
    'Arauca': ['Arauca', 'Tame', 'Saravena', 'Fortul', 'Puerto Rondón', 'Cravo Norte', 'Arauquita'],
    'Atlántico': ['Barranquilla', 'Soledad', 'Malambo', 'Sabanagrande', 'Puerto Colombia', 'Galapa', 'Palmar de Varela'],
    'Bolívar': ['Cartagena', 'Magangué', 'Turbaco', 'Arjona', 'El Carmen de Bolívar', 'San Pablo', 'Mompox'],
    'Boyacá': ['Tunja', 'Duitama', 'Sogamoso', 'Chiquinquirá', 'Paipa', 'Villa de Leyva', 'Puerto Boyacá'],
    'Caldas': ['Manizales', 'La Dorada', 'Chinchiná', 'Riosucio', 'Anserma', 'Villamaría', 'Palestina'],
    'Caquetá': ['Florencia', 'San Vicente del Caguán', 'Puerto Rico', 'La Montañita', 'Curillo', 'El Paujil'],
    'Casanare': ['Yopal', 'Aguazul', 'Villanueva', 'Tauramena', 'Monterrey', 'Paz de Ariporo'],
    'Cauca': ['Popayán', 'Santander de Quilichao', 'Puerto Tejada', 'Patía', 'Guapi', 'Corinto'],
    'Cesar': ['Valledupar', 'Aguachica', 'Bosconia', 'Codazzi', 'La Jagua de Ibirico', 'Chiriguaná'],
    'Chocó': ['Quibdó', 'Istmina', 'Condoto', 'Tadó', 'Acandí', 'Capurganá'],
    'Córdoba': ['Montería', 'Lorica', 'Cereté', 'Sahagún', 'Planeta Rica', 'Montelíbano'],
    'Cundinamarca': ['Bogotá', 'Soacha', 'Girardot', 'Zipaquirá', 'Facatativá', 'Chía', 'Mosquera', 'Madrid', 'Funza', 'Cajicá'],
    'Guainía': ['Inírida'],
    'Guaviare': ['San José del Guaviare', 'Calamar', 'El Retorno', 'Miraflores'],
    'Huila': ['Neiva', 'Pitalito', 'Garzón', 'La Plata', 'Campoalegre', 'Timaná'],
    'La Guajira': ['Riohacha', 'Maicao', 'Uribia', 'Manaure', 'San Juan del Cesar', 'Villanueva'],
    'Magdalena': ['Santa Marta', 'Ciénaga', 'Fundación', 'Aracataca', 'El Banco', 'Plato'],
    'Meta': ['Villavicencio', 'Acacías', 'Granada', 'Puerto López', 'Cumaral', 'San Martín'],
    'Nariño': ['Pasto', 'Tumaco', 'Ipiales', 'Túquerres', 'Samaniego', 'La Unión'],
    'Norte de Santander': ['Cúcuta', 'Villa del Rosario', 'Los Patios', 'Ocaña', 'Pamplona', 'Tibú'],
    'Putumayo': ['Mocoa', 'Puerto Asís', 'Orito', 'Valle del Guamuez', 'San Miguel', 'Villagarzón'],
    'Quindío': ['Armenia', 'Calarcá', 'La Tebaida', 'Montenegro', 'Quimbaya', 'Circasia'],
    'Risaralda': ['Pereira', 'Dosquebradas', 'Santa Rosa de Cabal', 'La Virginia', 'Marsella', 'Belén de Umbría'],
    'San Andrés y Providencia': ['San Andrés', 'Providencia'],
    'Santander': ['Bucaramanga', 'Floridablanca', 'Girón', 'Piedecuesta', 'Barrancabermeja', 'San Gil'],
    'Sucre': ['Sincelejo', 'Corozal', 'Sampués', 'San Marcos', 'Tolú', 'Coveñas'],
    'Tolima': ['Ibagué', 'Espinal', 'Melgar', 'Honda', 'Chaparral', 'Líbano'],
    'Valle del Cauca': ['Cali', 'Palmira', 'Buenaventura', 'Tuluá', 'Cartago', 'Buga', 'Jamundí', 'Yumbo'],
    'Vaupés': ['Mitú'],
    'Vichada': ['Puerto Carreño', 'La Primavera', 'Santa Rosalía', 'Cumaribo']
}

if __name__ == '__main__':
    app.run(debug=True, port=5001)
